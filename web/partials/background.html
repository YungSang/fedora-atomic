<article>
  <div class="container">
    <div class="starter-template">
      <h3>Packages and Images</h3>
      <p>
	Traditional GNU/Linux distributions come as a collection of
	packages, which one can assemble into a wide variety of
	potential trees, accomodating a potentially vast array of use
	cases.  A weakness of this model is that there are many system
	configurations which go untested, or only have limited
	testing.  It's very easy for upgraded systems to diverge from
	fresh installations.
      </p>
      <p>
	At the other end of the spectrum, systems
	like <a href="http://www.chromium.org/chromium-os">ChromeOS</a> and 
	<a href="https://coreos.com/">CoreOS</a> come pre-assembled,
	and target fixed use cases.  Their update systems reflect this
	targeting - they're not designed to allow much flexibility on
	the client side.</p>
      <h3>OSTree as a middle ground</h3>
      <p>
	With traditional package systems, while one may use an
	"image" as a basis for install, once installed, the system
	requires package management on the client.  Each client
	machine performs dependency resolution and updates package by
	package.
      </p>
      <p>
	OSTree encourages assembling <i>multiple</i> trees from a
	variety of packages on a build server, <i>naming</i> the
	resulting filesystem trees that are the combination of
	packages, and then <i>replicating</i> that to clients.
      </p>
      <p>
	However, unlike traditional image-based upgrades, client
	systems can <i>switch</i> between these pre-assembled trees.
	For example, one can start with a minimal "core" system, and
	then atomically upgrade to a larger system, perhaps with local
	documentation, tracing and profiling tools, etc.
      </p>
    </div>
  </div>
</article>
