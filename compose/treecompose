#!/usr/bin/env python
# Copyright (C) 2014 Colin Walters <walters@verbum.org>, Andy Grimm <agrimm@redhat.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

import json
import os
import sys
import tempfile
import argparse
import subprocess
from gi.repository import Gio, OSTree, GLib
from iniparse import configparser

# For our http server thread
import SimpleHTTPServer
import BaseHTTPServer
import threading
import urllib

def run_sync(args, **kwargs):
    """Wraps subprocess.check_call(), logging the command line too."""
    print "Running: %s" % (subprocess.list2cmdline(args), )
    subprocess.check_call(args, **kwargs)

class Composer(object):
    ATTRS = [ 'outputdir', 'workdir', 'srcdir', 'ostree_repo',
              'rpmostree_cache_dir', 'os_name', 'os_pretty_name',
              'tree_name', 'tree_file', 'arch', 'release', 'ref',
              'yum_baseurl', 'local_overrides',
            ]

    def __init__(self, configfile, release, selfdir='.'):
        self._repo = None
        defaults = { 'workdir': os.getcwd(),
                     'srcdir':  os.path.join(selfdir, '..'),
                     'rpmostree_cache_dir': os.path.join(os.getcwd(), release, 'cache'),
                     'yum_baseurl': None,
                     'local_overrides': None,
                   }

        settings = configparser.ConfigParser()
        settings.read(configfile)
        for attr in self.ATTRS:
            try:
                val = settings.get(release, attr)
            except configparser.NoOptionError, e:
                val = defaults.get(attr)
            setattr(self, attr, val)

        if not self.yum_baseurl:
            if self.release in [ '21', 'rawhide' ]:
                self.yum_baseurl = 'http://download.fedoraproject.org/pub/fedora/linux/development/%s/%s/os/' % (self.release, self.arch)
            else:
                self.yum_baseurl = 'http://download.fedoraproject.org/pub/fedora/linux/releases/%s/%s/os/' % (self.release, self.arch)

        return

    @property
    def repo(self):
        if self._repo is None:
            self._repo = OSTree.Repo(path=Gio.File.new_for_path(self.ostree_repo))
            self._repo.open(None)
        return self._repo

    def show_config(self):
        print "\n".join([ "%s=%s" % (x, str(getattr(self, x))) for x in self.ATTRS ])

    def compose_tree(self):
        # XXX: rpm-ostree should be handling this, I think
        if not os.path.exists(self.rpmostree_cache_dir):
            os.makedirs(self.rpmostree_cache_dir)
        _,origrev = self.repo.resolve_rev(self.ref, True)
        subprocess.check_call(['rpm-ostree', 'compose', 'tree',
                               '--repo=' + self.ostree_repo,
                               '--cachedir=' + self.rpmostree_cache_dir,
                               '%s/%s-%s.json' % (self.srcdir, self.os_name,
                                                  self.tree_name)])
        _,newrev = self.repo.resolve_rev(self.ref, True)
        return (origrev, newrev)

    def create_disks(self, tasks):
        # subprocess.check_call([selfdir + '/create-disks'])
        [res,rev] = self.repo.resolve_rev(self.ref, False)
        [res,commit] = self.repo.load_variant(OSTree.ObjectType.COMMIT, rev)

        commitdate = GLib.DateTime.new_from_unix_utc(OSTree.commit_get_timestamp(commit)).format("%c")
        print commitdate
        # XXX - Define this somewhere?
        imageoutputdir=os.path.join(self.outputdir, 'images')

        imagedir = os.path.join(imageoutputdir, rev[:8])
        if not os.path.exists(imagedir):
            os.makedirs(imagedir)

        # Ick
        tmpdir = tempfile.mkdtemp('', 'atomic')
        os.chdir(tmpdir)
        # guestfs runs qemu with reduced privileges apparently, so chmod a+rx
        os.chmod(tmpdir, os.stat(tmpdir).st_mode | 0555)
        imagestmpdir = os.path.join(tmpdir, 'images')
        os.makedirs(imagestmpdir)

        if 'installer' in tasks:
            imgtargetinstaller=os.path.join(imagestmpdir, 'install', '%s-installer.iso' % self.os_name)
            self.create_installer_image(tmpdir, imgtargetinstaller)

        if 'cloud' in tasks:
            # imgtargetbase=os.path.join(imagestmpdir, self.os_name + '.qcow2')
            imgtargetcloud=os.path.join(imagestmpdir, 'cloud', '%s.qcow2' % self.os_name)
            self.create_cloud_image(tmpdir, imgtargetcloud) # , imgtargetbase)

        # imgtargetvagrantlibvirt=os.path.join(imagestmpdir, 'vagrant-libvirt', '%s.box' % self.os_name)
        # create_vagrant_image()

    def create_installer_image(self, tmpdir, target):
        lorax_opts = []
        if self.local_overrides:
            lorax_opts.extend([ '-s', self.local_overrides ])
        http_proxy = os.environ.get('http_proxy')
        if http_proxy:
            lorax_opts.extend([ '--proxy', http_proxy ])

        lorax_workdir = os.path.join(tmpdir, 'lorax')
        os.makedirs(lorax_workdir)
        run_sync(['lorax', '--nomacboot',
                  '--add-template=%s/lorax-embed-repo.tmpl' % self.srcdir,
                  '--add-template-var=ostree_repo=%s' % self.ostree_repo,
                  '--add-template-var=ostree_ref=%s' % self.ref,
                  '-p', self.os_pretty_name, '-v', self.release,
                  '-r', self.release, '-s', self.yum_baseurl,
                  ] + lorax_opts + ['output'],
                 cwd=lorax_workdir)
        os.makedirs(os.path.dirname(target))
        # Right now we only take the boot.iso (which is really
        # installer.iso since we used a template to inject data)
        os.rename(lorax_workdir + '/output/images/boot.iso', target)

    def create_cloud_image(self, tmpdir, target):
        targetdir = os.path.dirname(target)
        if not os.path.exists(targetdir):
            os.makedirs(targetdir)

        port_file_path = tmpdir + '/repo-port'
        subprocess.check_call(['ostree', 'trivial-httpd', '--autoexit', '--daemonize', '--port-file', port_file_path],
                                         cwd=self.ostree_repo + '/..')

        httpd_port = open(port_file_path).read().strip()
        print "trivial httpd port=%s" % (httpd_port, )

        # TODO: Pull kickstart from separate git repo
        kickstart = open(os.path.join(self.srcdir, 'fedora-%s-cloud-atomic.ks' % self.release)).read()
        kickstart = kickstart.replace('@OSTREE_PORT@', httpd_port)
        param_fd, param_file = tempfile.mkstemp('', 'imgfac-params')

        parameters =  { "install_script": kickstart, "generate_icicle": False }
        param = os.fdopen(param_fd, 'w')
        param.write(json.dumps(parameters))
        param.close()

        subprocess.check_call(['imagefactory', 'base_image',
                               os.path.join(self.srcdir,
                                            'fedora-%s.tdl' % self.release),
                               '--parameters', param_file,
        ])

## End Composer

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Compose OSTree trees and build images.')
    parser.add_argument('-c', '--config', type=str, default='./config.ini', help='Path to config file')
    parser.add_argument('-r', '--release', type=str, default='rawhide', help='Release to compose (references a config file section)')
    parser.add_argument('-t', '--task', action='append', help='Perform only these steps', default=None)
    parser.add_argument('-v', '--verbose', action='store_true', help='verbose output')
    args = parser.parse_args()

    selfdir=os.path.dirname(sys.argv[0])

    composer = Composer(args.config, args.release, selfdir)
    composer.show_config()

    if args.task is None:
        args.task = ['tree', 'cloud', 'installer']

    if 'tree' in args.task:
        origrev, newrev = composer.compose_tree()
    else:
        origrev = None
        _,newrev = composer.repo.resolve_rev(composer.ref, True)

    if origrev != newrev:
        print "%s => %s" % (composer.ref, newrev)
        composer.create_disks(args.task)
    else:
        print "%s is unchanged at %s" % (composer.ref, origrev)

